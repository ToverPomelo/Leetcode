# 32. Longest Valid Parentheses
&emsp;&emsp;原题地址：[https://leetcode.com/problems/longest-valid-parentheses/](https://leetcode.com/problems/longest-valid-parentheses/) <br/>

# 题目描述
&emsp;&emsp;给定一堆括号（只有左括号'('和')'），找出其中最长的合法括号组合的长度，比如"()"或"((())())"是合法的，"())"是不合法的<br/>

# 思路
&emsp;&emsp;可以先联想一下经典的括号匹配问题：给定一堆括号，判定这堆括号是不是合法的。这个问题的经典解法是用栈解决的，遇到左括号就把它入栈，遇到右括号时就弹栈，如果弹栈时发现栈位空则这堆括号不合法，如果遍历完所有括号后栈为空则这堆括号合法，否则不合法。<br/>
&emsp;&emsp;这题可以在经典括号匹配算法上进行改进，首先同样也是用栈来解决，栈中存两种元素：数字和括号的字符（先不考虑如何在c++中用栈存放两种类型数据的问题），括号表示的是从左到右遍历的括号，数字表示夹在这些括号中有多少个括号是合法的，比如输入的是"(((())("，会有"((4("。<br/>
&emsp;&emsp;然后跟经典括号匹配问题类似，遍历输入的括号字符串，如果遇到左括号就入栈，遇到右括号时，若栈顶（这里栈顶指除去数字的括号，具体做法先略过）为左括号则弹出左括号，把数字2入栈（这里还有一个把相邻数字合并加起来的步骤，略了）；否则把当前的括号入栈。最后遍历完所有括号后，统计栈中最大的数字就是答案了。<br/>
&emsp;&emsp;下面是一些细节：首先是在栈中同时存数字和括号的问题，这个可以通过编码解决，因为数字是不会有负数的，所以可以把'('编码成-1，把')'编码成-2。<br/>
&emsp;&emsp;还有数字的合并问题就咕咕咕了，看代码就好了。<br/>
